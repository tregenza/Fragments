The What of Fragments

Date: November 23, 2025

Abstract

This document defines the technical implementation of the Fragment Protocol. It specifies the Directory Structure, the JSON Schema, and the cryptographic verification handshake.

1. The Container Structure

A "Fragment" is not a single file, but a web-accessible directory containing a hierarchy of sub-directories.

This structure isolates concerns: The Source (immutable facts) is kept distinct from the Presentation (guidance) and Expressions (output).

Standard Directory Layout:

/fragment-uuid/
├── fragment.json           // The Manifest (Signed by Publisher)
│
├── source/                 // Signed by Author (Single Signed Directory)
│   ├── article.md
│   ├── captions.txt
│   └── image_one.jpg
│
├── presentation/           // (Optional) Signed by Publisher via Manifest
│   └── style_guide.md
│
└── expressions/            // (Optional) Signed by Publisher via Manifest
    ├── audio/
    │   └── reading.mp3
    └── print/
        └── layout.pdf


Access Logic:
An AI Agent given the URL https://example.com/news/fragment-123/ looks for fragment.json at that root. It then resolves files relative to the sub-directories defined in the Manifest.

2. The Schema Definition

The Manifest (fragment.json) acts as the inventory and security log for the Bundle.

{
  "protocol": "fragment-v1",
  "id": "uuid-v4-unique-identifier",
  
  // 1. METADATA
  "meta": {
    "title": "The Future of AI Publishing",
    "author": "Jane Doe",
    "publisher_domain": "nytimes.com", 
    "published_at": "2025-11-20T14:00:00Z",
    "summary": "A proposal for a new AI-first publishing standard.",
    "keywords": ["AI", "Protocol", "Philosophy"]
  },

  // 2. CONTENT: The Core Components
  "content": {
    
    // --- A. THE SOURCE (The Facts) ---
    // Immutable, signed by the Author.
    "source": {
      "base_path": "source/", 
      "files": [
        {
          "role": "main",
          "mime_type": "text/markdown",
          "path": "article.md",
          "integrity": "sha256-[hash-of-article]"
        },
        {
          "role": "asset",
          "mime_type": "image/jpeg",
          "path": "image_one.jpg",
          "integrity": "sha256-[hash-of-image-one]"
        }
      ],
      
      // RENAMED: 'ownership' replaces 'commercial' to include public domain/non-profit
      "ownership": {
        "license": "CC-BY-SA-4.0",
        "attribution_text": "Originally published by Jane Doe.",
        "payment_pointer": "[https://janedoe.com/support](https://janedoe.com/support)" // Optional
      },

      "author_signature": {
         "signer_name": "Jane Doe",
         "signer_domain": "janedoe.com",
         // Signs the hash of all files in the 'source/' directory + ownership JSON string
         "signature": "[Base64 Signature of Source Collection]"
      }
    },

    // --- B. THE PRESENTATION (The Intent) ---
    // Guidance on how the AI should interpret the source.
    "presentation": {
      "base_path": "presentation/",
      "intent": "Technical Proposal", 
      "files": [
          {
              "role": "style_guide",
              "mime_type": "text/markdown",
              "path": "style_guide.md",
              "integrity": "sha256-[hash-of-style-guide]"
          }
      ]
    },
    
    // --- C. THE EXPRESSIONS (The Result) ---
    // Pre-computed views generated by the Publisher or Third Parties.
    "expressions": {
        
        "audio_v1": {
            "medium": "audiobook",
            "provider": "Audible Studios", 
            "description": "Author read-through",
            "files": [
                {
                    "mime_type": "audio/mpeg",
                    "path": "expressions/audio/reading.mp3",
                    "integrity": "sha256-[hash-of-mp3]"
                }
            ]
        },

        "web_canonical": {
            "medium": "webpage",
            "provider": "NYT Web Team",
            "description": "Official NYT interactive layout",
            "url": "[https://nytimes.com/2025/11/20/technology/ai-publishing.html](https://nytimes.com/2025/11/20/technology/ai-publishing.html)",
            "integrity": "sha256-[hash-of-remote-html-content]" 
        }
    }
  },

  // 3. ADDITIONAL INFO (Optional)
  "additional": {
    "lineage": {
        "previous_version_hash": null,
        "update_type": "original"
    },
    "identifiers": {
        "isbn": "978-3-16-148410-0",
        "doi": "10.1000/182"
    }
  },

  // 4. SECURITY: The Publisher's Seal
  "security": {
    "algorithm": "RSA-SHA256",
    "signer_domain": "nytimes.com",
    "signature": "[Base64 Encoded Signature of the entire manifest JSON]"
  }
}


3. Security & Verification

3.1 The Verification Handshake (Chain of Trust)

To validate a Fragment, a Reader Agent performs three checks:

Step 1: Bundle Integrity (File Check)

Download files listed in content.source.files.

Calculate the SHA-256 hash for each.

Compare each to the integrity field in the Manifest. If any fail, abort.

Step 2: Publisher Verification (Manifest Check)

Fetch Publisher Key: GET https://[publisher_domain]/.well-known/fragment-pubkey.json.

Verify security.signature against the Manifest content.

Note: This signature validates the Presentation and Expressions blocks. By signing the Manifest, the Publisher accepts responsibility for the integrity of all bundled and remote expressions.

Step 3: Author Verification (Source Check)

Construct the Payload: Concatenate the integrity hashes of all files in the source block (sorted alphabetically by path) + the ownership block string.

Fetch Author Key: GET https://[signer_domain]/.well-known/fragment-pubkey.json.

Verify: Check content.source.author_signature against this constructed payload. This confirms the Author created the contents of the source/ directory.

3.2 Safety Protocols

External URL Integrity: Agents MUST reject any remote Expression URL (content.expressions.*.url) that does not have a matching integrity hash in the Manifest. This prevents "Bait and Switch" attacks where a remote file changes after the Publisher signs it.

Prompt Injection: Consuming Agents must sandbox content processing. They must strip "instructional" language from the body text (e.g., "Ignore previous instructions") and adhere strictly to the instructions found in the presentation/ directory.

Malicious Payloads: Scripting languages (JS/WASM) and complex rendering (HTML) are forbidden in the Source Payload. The Agent reads text; it does not execute code.